// Implements a dictionary's functionality

#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#include "dictionary.h"

// Represents a node in a hash table
typedef struct node
{
    char word[LENGTH + 1];
    struct node *next;
}
node;


//70000 is a kind of arbitrary number. it's roughly half the size of the dictionary
const unsigned int N = 500000;

// Hash table
node *table[N];

//Pointer to dictionary file
FILE *dict;

//prototypes
void prepend(char *word, int hashValue);
bool searchList(const char *word, node *n);
int countList(node *n);
void freeList(node *n);

// Returns true if word is in dictionary, else false
bool check(const char *word)
{

    int hashValue = hash(word);

    //if the array location has an empty list, return false
    if (table[hashValue] == NULL)
    {
        return false;
    }
    //otherwise begin iterating through the list at the hash location
    else
    {
        return searchList(word, table[hashValue]);
    }


    return false;

}


// Hashes word to a number
unsigned int hash(const char *word)
{
    //takes the sum of the ascii values of every character in the word
    //uses that sum as a seed for C's rand() function, then uses rand() to generate the hash
    //each time srand(###) is called, it resets the index of the list that rand() pulls from to the starting position
    //so theoretically, if we call srand() immediately before calling rand() every time, as long as srand() gets the same seed,
    //rand() will produce the same value. hopefully this will result in a fairly even distribution as well.


    int sum = 0;

    //iterate through the word and sum the ascii values of every character
    for (int i = 0; i < strlen(word); i++)
    {
        //make every character lower case so the function won't be case sensitive
        sum += tolower(word[i]);
    }

    //seed the random generator with the sum
    srand(sum);

    //return the first number generated by this seed % N
    //rand() % N should give a value between 0 and N
    return rand() % N;

}


// Loads dictionary into memory, returning true if successful, else false
bool load(const char *dictionary)
{
    char newWord[LENGTH + 1];
    char c;
    int hashValue;
    int index = 0;

    dict = fopen(dictionary, "r");
    if (dict == NULL)
    {
        return false;
    }

    while (fread(&c, sizeof(char), 1, dict))
    {
        //read the dictionary character by character
        if (c != '\n')
        {
            newWord[index] = c;
            index++;
        }
        //if we hit a newline char, we've finished a word. hash it and put it in the table
        else
        {
            newWord[index] = '\0';

            //DEBUG: Print the word we're about to hash
            //printf("%s\n", newWord);

            hashValue = hash(newWord);

            //if a node doesn't already exist at the correct position, create it
            if (table[hashValue] == NULL)
            {
                node *n = malloc(sizeof(node));
                strcpy(n->word, newWord);
                n->next = NULL;
                table[hashValue] = n;
            }
            //otherwise, prepend it to the end of the list at the correct position
            else
            {
                prepend(newWord, hashValue);
            }

            index = 0;

        }
    }

    return true;
}


//Returns number of words in dictionary if loaded, else 0 if not yet loaded
unsigned int size(void)
{
    int count = 0;

    //iterate through the whole array, and start counting any lists that aren't NULL
    for (int i = 0; i < N; i++)
    {
        if (table[i] != NULL)
        {
            count += countList(table[i]);
        }
    }

    return count;
}


// Unloads dictionary from memory, returning true if successful, else false
bool unload(void)
{
    //iterate through array and begin freeing any nodes that are not NULL
    //STARTING WITH THE END OF EACH LIST
    for (int i = 0; i < N; i++)
    {
        if (table[i] != NULL)
        {
            freeList(table[i]);
        }
    }

    fclose(dict);

    return true;
}



//inserts a new item at the start of a linked list
void prepend(char *word, int hashValue)
{
    //create a temporary node
    node *temp = malloc(sizeof(node));

    //assign a value to the new node
    strcpy(temp->word, word);

    //new node points to first node
    temp->next = table[hashValue];

    //hash array points to new node
    table[hashValue] = temp;
}


//traverses a linked list and returns the number of nodes
int countList(node *n)
{
    //count the current node
    int count = 1;

    //if there is a next node, pass it to countList and add the new total to the current count
    if (n->next != NULL)
    {
        count += countList(n->next);
    }

    //return the final count
    return count;
}

void freeList(node *n)
{

    if (n->next != NULL)
    {
        freeList(n->next);
    }

    free(n);

    return;
}



bool searchList(const char *word, node *n)
{
    if (n == NULL)
    {
        return false;
    }

    if (strcasecmp(word, n->word) == 0)
    {
        return true;
    }

    return searchList(word, n->next);

}